// Example implementation for src/lib/api.ts
import axios from 'axios';
import { DetectionResult } from '@/types/detection';

// Use localStorage for configuration with default to localhost:8000
const API_BASE_URL = localStorage.getItem('api_base_url') || 'http://localhost:8000';
const API_KEY = localStorage.getItem('api_key') || '';

// Configure axios instance
const api = axios.create({
  baseURL: API_BASE_URL,
  timeout: 30000, // 30 seconds
  headers: API_KEY ? { 'Authorization': `Bearer ${API_KEY}` } : {}
});

// Update API configuration
export function updateAPIConfig(baseUrl: string, apiKey: string) {
  localStorage.setItem('api_base_url', baseUrl);
  localStorage.setItem('api_key', apiKey);
  
  // Update axios instance
  api.defaults.baseURL = baseUrl;
  if (apiKey) {
    api.defaults.headers.common['Authorization'] = `Bearer ${apiKey}`;
  } else {
    delete api.defaults.headers.common['Authorization'];
  }
}

// Test API connection
export async function testAPIConnection(): Promise<boolean> {
  try {
    const response = await api.get('/health');
    return response.status === 200 && response.data.status === 'ok';
  } catch (error) {
    console.error('API connection test failed:', error);
    return false;
  }
}

// Detect deepfake with specific model
async function detectWithModel(imageData: string | File, modelName: string): Promise<any> {
  const formData = new FormData();
  
  if (typeof imageData === 'string') {
    // Convert base64 to blob
    const response = await fetch(imageData);
    const blob = await response.blob();
    formData.append('file', blob, 'image.jpg');
  } else {
    formData.append('file', imageData);
  }
  
  const response = await api.post(`/predict/${modelName.toLowerCase()}`, formData, {
    headers: {
      'Content-Type': 'multipart/form-data'
    }
  });
  
  return response.data;
}

// Main detection function that calls the API
export async function detectDeepfakeAPI(
  imageData: string | File,
  config?: { models?: string[]; returnHeatmaps?: boolean }
): Promise<DetectionResult> {
  const models = config?.models || ['CNN', 'EfficientNet', 'VGG16'];
  
  // Map model names to backend model names
  const modelMapping: Record<string, string> = {
    'CNN': 'cnn',
    'EfficientNet': 'effnet',
    'VGG16': 'vgg'
  };
  
  // Get predictions from all requested models
  const predictions = await Promise.all(
    models.map(async (model) => {
      const backendModel = modelMapping[model] || model.toLowerCase();
      const result = await detectWithModel(imageData, backendModel);
      
      // Convert backend response to frontend model
      const isReal = result.predicted_class === 0;
      const realConfidence = isReal ? result.probabilities[0] * 100 : result.probabilities[1] * 100;
      const fakeConfidence = isReal ? result.probabilities[1] * 100 : result.probabilities[0] * 100;
      
      return {
        name: model,
        realConfidence: Math.round(realConfidence),
        fakeConfidence: Math.round(fakeConfidence),
      };
    })
  );
  
  // Calculate ensemble prediction
  const fakeVotes = predictions.filter(p => p.fakeConfidence > p.realConfidence).length;
  const isDeepfake = fakeVotes > predictions.length / 2;
  
  // Calculate ensemble confidence
  const ensembleConfidence = Math.round(
    predictions.reduce((sum, p) => sum + (isDeepfake ? p.fakeConfidence : p.realConfidence), 0) / predictions.length
  );
  
  // Create image URL if file was provided
  const imageUrl = imageData instanceof File ? URL.createObjectURL(imageData) : imageData;
  
  return {
    prediction: isDeepfake ? "Fake" : "Real",
    isDeepfake,
    ensembleConfidence,
    modelPredictions: predictions,
    timestamp: new Date().toISOString(),
    // Heatmaps would require additional backend support
    cnnHeatmap: undefined,
    efficientNetHeatmap: undefined,
    vitHeatmap: undefined,
    imageUrl
  };
}